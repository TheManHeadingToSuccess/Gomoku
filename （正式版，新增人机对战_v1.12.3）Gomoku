import java.awt.*;
import java.util.ArrayList;

class chess {
    private final int x;
    private final int y;
    private final int color;

    chess( int x, int y, int color ) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    public int getX() {
        return x;
    }
    public int getY() {
        return y;
    }
    public int getColor() {
        return color;
    }
}
public class NewGomoku4 {
    public static void main(String[] args) throws ArrayIndexOutOfBoundsException{
        startGomoku();
    }
    public static void startGomoku() {
        StdDraw.clear();
        StdDraw.enableDoubleBuffering();
        int switcher;  //声明开关
        formFirstGUI();  //显示首页
        while ( true ) {  //实现鼠标实时监听

            do {
                switcher = 0;
                while ( StdDraw.isMousePressed() ) {
                    if ( clickButtonToChooseMode(1) ) switcher = 1;
                    if ( clickButtonToChooseMode(2) ) switcher = 2;
                    if ( clickButtonToExit1() ) System.exit(0);
                }
            } while ( switcher == 0 );  //选择模式：1——PVP；2——PVC

            switch ( switcher ) {
                case 1 :
                    chooseSizeGUI();  //显示选择棋盘规格界面
                    do {
                        switcher = 0;
                        while (StdDraw.isMousePressed()) {
                            if ( clickButtonToFormSize(15) ) switcher = 11;
                            if ( clickButtonToFormSize(17) ) switcher = 12;
                            if ( clickButtonToFormSize(19) ) switcher = 13;
                        }
                    } while ( switcher == 0 );  //选择不同的棋盘规格

                    switch ( switcher ) {
                        case 11 :
                            gamePVP( 15 );
                        case 12 :
                            gamePVP( 17 );
                        case 13 :
                            gamePVP( 19 );
                    }  //开始游戏
                case 2 :
                    chooseSizeGUI();  //显示选择棋盘规格界面
                    do {
                        switcher = 0;
                        while (StdDraw.isMousePressed()) {
                            if ( clickButtonToFormSize(15) ) switcher = 21;
                            if ( clickButtonToFormSize(17) ) switcher = 22;
                            if ( clickButtonToFormSize(19) ) switcher = 23;
                        }
                    } while ( switcher == 0 );  //选择不同的棋盘规格

                    switch ( switcher ) {
                        case 21 :
                            chooseColorGUI();
                            do {
                                switcher = 0;
                                while ( StdDraw.isMousePressed() ) {
                                    if ( clickButtonToChooseMode(1) ) switcher = 1;
                                    if ( clickButtonToChooseMode(2) ) switcher = 2;
                                }
                            } while ( switcher == 0 );

                            switch ( switcher ) {
                                case 1:
                                    gamePVC1( 15 );
                                case 2:
                                    gamePVC2( 15 );
                            }

                        case 22 :
                            chooseColorGUI();
                            do {
                                switcher = 0;
                                while ( StdDraw.isMousePressed() ) {
                                    if ( clickButtonToChooseMode(1) ) switcher = 1;
                                    if ( clickButtonToChooseMode(2) ) switcher = 2;
                                }
                            } while ( switcher == 0 );

                            switch ( switcher ) {
                                case 1:
                                    gamePVC1( 17 );
                                case 2:
                                    gamePVC2( 17 );
                            }

                        case 23 :
                            chooseColorGUI();
                            do {
                                switcher = 0;
                                while ( StdDraw.isMousePressed() ) {
                                    if ( clickButtonToChooseMode(1) ) switcher = 1;
                                    if ( clickButtonToChooseMode(2) ) switcher = 2;
                                }
                            } while ( switcher == 0 );

                            switch ( switcher ) {
                                case 1:
                                    gamePVC1( 19 );
                                case 2:
                                    gamePVC2( 19 );
                            }
                    }
            }
        }
    }
    //以上为开始游戏函数

    public static void gamePVP( int boardSize ) {

        ArrayList<chess> undo = new ArrayList<>();
        int countUndoBlack = 0;
        int countUndoWhite = 0;

        formBoard(boardSize);

        int[][] cross = new int[2*boardSize + 1][2*boardSize + 1];
        for (int i = 1; i < boardSize + 1; i++) {
            for (int j = 1; j < boardSize + 1; j++) {
                cross[i][j] = 0;
            }
        }
        int color = 2;
        StdDraw.setPenColor(Color.BLACK);
        int judgment;
        int switcher;
        while (true) {

            if ( StdDraw.isMousePressed() &&
                    (int) Math.round(StdDraw.mouseX()) <= (boardSize + 1) &&
                    (int) Math.round(StdDraw.mouseY()) <= (boardSize + 1)
            )
            {
                do {
                    switcher = 0;
                    while (StdDraw.isMousePressed()) {

                        if ( CanInput(cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())])
                        ) {
                            cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())] = color;
                            chess aChess = new chess((int) Math.round(StdDraw.mouseX()), (int) Math.round(StdDraw.mouseY()),
                                    color );
                            undo.add(aChess);
                            if (color == 1) {
                                color++;
                            } else if (color == 2) {
                                color--;
                            }
                        }

                        if ( isForbiddenMove( (int) Math.round(StdDraw.mouseY()), (int) Math.round(StdDraw.mouseX()),
                                cross, boardSize )
                        )
                        {
                            forbiddenMove( cross, undo, boardSize );
                            color = 2;
                        }

                        for (int i = 1; i < boardSize + 1; i++) {
                            for (int j = 1; j < boardSize + 1; j++) {

                                if (cross[i][j] == 1) {
                                    StdDraw.setPenColor(Color.WHITE);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }
                                if (cross[i][j] == 2) {
                                    StdDraw.setPenColor(Color.BLACK);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }

                                judgment = checkVictory(j, i, 1, cross, boardSize);
                                if (judgment == 1) {
                                    victoryGUI(1);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }
                                judgment = checkVictory(j, i, 2, cross, boardSize);
                                if (judgment == 2) {
                                    victoryGUI(2);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }

                                switch (switcher) {
                                    case 31:
                                        if (judgment == 2) {
                                            System.out.println("GAME OVER. BLACK WINS.");
                                        } else {
                                            System.out.println("GAME OVER. WHITE WINS.");
                                        }
                                        System.exit(0);
                                    case 32:
                                        startGomoku();
                                }

                            }
                        }
                        switcher = 1;
                    }

                } while (switcher == 1);
            }
            else if ( StdDraw.isMousePressed() && clickButtonToUndo( boardSize) ){
                do {
                    switcher = 4;
                    while ( StdDraw.isMousePressed() ) {
                        if ( clickButtonToUndo( boardSize) )
                            switcher = 5;
                    }

                    if ( switcher == 5 && canUndo( undo ) ) {
                        chess former = undo.get( undo.size() - 1 );
                        int x = former.getX();
                        int y = former.getY();

                        undo.remove( undo.size() - 1 );
                        cross[y][x] = 0;
                        showBoard( boardSize, cross );
                        if (color == 1) {
                            color++;
                            countUndoBlack++;
                            if ( countUndoBlack <= 5 )
                                undoTitle( boardSize, countUndoBlack, 2, cross );
                            else foulTittle( boardSize, cross );
                        }
                        else if (color == 2) {
                            color--;
                            countUndoWhite++;
                            if ( countUndoWhite <= 5 )
                                undoTitle( boardSize, countUndoWhite, 1, cross );
                            else foulTittle( boardSize, cross );
                        }
                    }
                } while ( switcher == 5 );
            }
        }
    }
    //以上为人人对战函数

    public static void gamePVC1( int boardSize ) {

        ArrayList<chess> undo = new ArrayList<>();
        int countUndoBlack = 0;
        int countUndoWhite = 0;

        formBoard(boardSize);

        int[][] cross = new int[2*boardSize + 1][2*boardSize + 1];
        for (int i = 1; i < boardSize + 1; i++) {
            for (int j = 1; j < boardSize + 1; j++) {
                cross[i][j] = 0;
            }
        }
        int color = 2;
        StdDraw.setPenColor(Color.BLACK);
        int judgment;
        int switcher;
        while (true) {

            if ( StdDraw.isMousePressed() &&
                    (int) Math.round(StdDraw.mouseX()) <= (boardSize + 1) &&
                    (int) Math.round(StdDraw.mouseY()) <= (boardSize + 1)
            )
            {

                do {
                    switcher = 0;
                    while (StdDraw.isMousePressed()) {

                        if ( CanInput(cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())])
                        ) {
                            cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())] = color;
                            chess aChess = new chess((int) Math.round(StdDraw.mouseX()), (int) Math.round(StdDraw.mouseY()),
                                    color );
                            undo.add(aChess);

                            computerFindBestPlaceAndPutDownAChess( boardSize, cross, undo, 1 );
                        }

                        if ( isForbiddenMove( (int) Math.round(StdDraw.mouseY()), (int) Math.round(StdDraw.mouseX()),
                                cross, boardSize )
                        )
                        {
                            forbiddenMove( cross, undo, boardSize );
                            color = 2;
                        }

                        for (int i = 1; i < boardSize + 1; i++) {
                            for (int j = 1; j < boardSize + 1; j++) {

                                if (cross[i][j] == 1) {
                                    StdDraw.setPenColor(Color.WHITE);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }
                                if (cross[i][j] == 2) {
                                    StdDraw.setPenColor(Color.BLACK);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }

                                judgment = checkVictory(j, i, 1, cross, boardSize);
                                if (judgment == 1) {
                                    victoryGUI(1);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }
                                judgment = checkVictory(j, i, 2, cross, boardSize);
                                if (judgment == 2) {
                                    victoryGUI(2);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }

                                switch (switcher) {
                                    case 31:
                                        if (judgment == 2) {
                                            System.out.println("GAME OVER. BLACK WINS.");
                                        } else {
                                            System.out.println("GAME OVER. WHITE WINS.");
                                        }
                                        System.exit(0);
                                    case 32:
                                        startGomoku();
                                }

                            }
                        }
                        switcher = 1;
                    }

                } while (switcher == 1);
            }
            else if ( StdDraw.isMousePressed() && clickButtonToUndo( boardSize) ){
                do {
                    switcher = 4;
                    while ( StdDraw.isMousePressed() ) {
                        if ( clickButtonToUndo( boardSize) )
                            switcher = 5;
                    }

                    if ( switcher == 5 && canUndo( undo ) ) {
                        chess former = undo.get( undo.size() - 1 );
                        int x = former.getX();
                        int y = former.getY();

                        undo.remove( undo.size() - 1 );
                        cross[y][x] = 0;
                        showBoard( boardSize, cross );
                        if (color == 1) {
                            color++;
                            countUndoBlack++;
                            if ( countUndoBlack <= 5 )
                                undoTitle( boardSize, countUndoBlack, 2, cross );
                            else foulTittle( boardSize, cross );
                        }
                        else if (color == 2) {
                            color--;
                            countUndoWhite++;
                            if ( countUndoWhite <= 5 )
                                undoTitle( boardSize, countUndoWhite, 1, cross );
                            else foulTittle( boardSize, cross );
                        }
                    }
                } while ( switcher == 5 );
            }
        }
    }

    public static void gamePVC2( int boardSize ) {

        ArrayList<chess> undo = new ArrayList<>();
        int countUndoBlack = 0;
        int countUndoWhite = 0;

        formBoard2(boardSize);

        int[][] cross = new int[2*boardSize + 1][2*boardSize + 1];
        for (int i = 1; i < boardSize + 1; i++) {
            for (int j = 1; j < boardSize + 1; j++) {
                cross[i][j] = 0;
            }
        }
        cross[(boardSize+1)/2][(boardSize+1)/2] = 2;
        int color = 1;
        StdDraw.setPenColor(Color.BLACK);
        int judgment;
        int switcher;
        while (true) {

            if ( StdDraw.isMousePressed() &&
                    (int) Math.round(StdDraw.mouseX()) <= (boardSize + 1) &&
                    (int) Math.round(StdDraw.mouseY()) <= (boardSize + 1)
            )
            {

                do {
                    switcher = 0;
                    while (StdDraw.isMousePressed()) {

                        if ( CanInput(cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())])
                        ) {
                            cross[(int) Math.round(StdDraw.mouseY())][(int) Math.round(StdDraw.mouseX())] = color;
                            chess aChess = new chess((int) Math.round(StdDraw.mouseX()), (int) Math.round(StdDraw.mouseY()),
                                    color );
                            undo.add(aChess);

                            computerFindBestPlaceAndPutDownAChess( boardSize, cross, undo, 2 );
                        }

                        if ( isForbiddenMove( (int) Math.round(StdDraw.mouseY()), (int) Math.round(StdDraw.mouseX()),
                                cross, boardSize )
                        )
                        {
                            forbiddenMove( cross, undo, boardSize );
                            color = 2;
                        }

                        for (int i = 1; i < boardSize + 1; i++) {
                            for (int j = 1; j < boardSize + 1; j++) {

                                if (cross[i][j] == 1) {
                                    StdDraw.setPenColor(Color.WHITE);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }
                                if (cross[i][j] == 2) {
                                    StdDraw.setPenColor(Color.BLACK);
                                    StdDraw.filledCircle(j, i, 0.4);
                                    StdDraw.show();

                                }

                                judgment = checkVictory(j, i, 1, cross, boardSize);
                                if (judgment == 1) {
                                    victoryGUI(1);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }
                                judgment = checkVictory(j, i, 2, cross, boardSize);
                                if (judgment == 2) {
                                    victoryGUI(2);
                                    do {
                                        switcher = 3;
                                        while (StdDraw.isMousePressed()) {
                                            if (clickButtonToExit2()) switcher = 31;
                                            if (clickButtonToPlayAgain()) switcher = 32;
                                        }
                                    } while (switcher == 3);
                                }

                                switch (switcher) {
                                    case 31:
                                        if (judgment == 2) {
                                            System.out.println("GAME OVER. BLACK WINS.");
                                        } else {
                                            System.out.println("GAME OVER. WHITE WINS.");
                                        }
                                        System.exit(0);
                                    case 32:
                                        startGomoku();
                                }

                            }
                        }
                        switcher = 1;
                    }

                } while (switcher == 1);
            }
            else if ( StdDraw.isMousePressed() && clickButtonToUndo( boardSize) ){
                do {
                    switcher = 4;
                    while ( StdDraw.isMousePressed() ) {
                        if ( clickButtonToUndo( boardSize) )
                            switcher = 5;
                    }

                    if ( switcher == 5 && canUndo( undo ) ) {
                        chess former = undo.get( undo.size() - 1 );
                        int x = former.getX();
                        int y = former.getY();

                        undo.remove( undo.size() - 1 );
                        cross[y][x] = 0;
                        showBoard( boardSize, cross );
                        if (color == 1) {
                            color++;
                            countUndoBlack++;
                            if ( countUndoBlack <= 5 )
                                undoTitle( boardSize, countUndoBlack, 2, cross );
                            else foulTittle( boardSize, cross );
                        }
                        else if (color == 2) {
                            color--;
                            countUndoWhite++;
                            if ( countUndoWhite <= 5 )
                                undoTitle( boardSize, countUndoWhite, 1, cross );
                            else foulTittle( boardSize, cross );
                        }
                    }
                } while ( switcher == 5 );
            }
        }
    }

    public static void formFirstGUI() {
        StdDraw.clear();
        StdDraw.setPenColor(StdDraw.BLACK);
        final Font title = new Font("SansSerif", Font.BOLD, 40);
        final Font button = new Font("SansSerif", Font.PLAIN, 20);
        final Font exit = new Font("SansSerif", Font.PLAIN, 15);

        StdDraw.setFont( title );
        StdDraw.text( 0.5, 0.8, "Gomoku" );
        //Make Button1.
        StdDraw.setPenColor( 0, 0, 170 );
        StdDraw.filledRectangle( 0.5, 0.6, 0.2, 0.075 );
        StdDraw.filledCircle( 0.3, 0.6, 0.075 );
        StdDraw.filledCircle( 0.7, 0.6, 0.075 );
        StdDraw.setFont( button );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.5, 0.6, "Play With People" );
        //Make Button2.
        StdDraw.setPenColor( 0, 0, 170 );
        StdDraw.filledRectangle( 0.5, 0.4, 0.2, 0.075 );
        StdDraw.filledCircle( 0.3, 0.4, 0.075 );
        StdDraw.filledCircle( 0.7, 0.4, 0.075 );
        StdDraw.setFont( button );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.5, 0.40, "Play With Computer" );
        //Make Exit button.
        StdDraw.setPenColor( 204, 34, 0 );
        StdDraw.filledRectangle( 0.9, 0.05, 0.05, 0.03 );
        StdDraw.filledCircle( 0.85, 0.05, 0.03 );
        StdDraw.filledCircle( 0.95, 0.05, 0.03 );
        StdDraw.setFont( exit );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.9, 0.05, "Exit" );
        //Top left decoration.
        StdDraw.setPenColor( 0, 0, 170 );
        double[] triangleX = { 0.0, 0.0, 0.1 };
        double[] triangleY = { 0.9, 1.0, 1.0 };
        StdDraw.filledPolygon( triangleX, triangleY );
        //Edition.
        StdDraw.setFont( exit );
        StdDraw.setPenColor(128, 128, 128);
        StdDraw.text( 0.15, 0.03, "1.0.0.111921_beta" );
        StdDraw.show();
    }
    public static void chooseSizeGUI() {
        StdDraw.clear();
        final Font title = new Font("SansSerif", Font.BOLD, 40);
        final Font button = new Font("SansSerif", Font.PLAIN, 20);
        final Font exit = new Font("SansSerif", Font.PLAIN, 15);

        StdDraw.setFont(title);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(0.5, 0.8, "Choose Board Size");
        //Make subButton1.
        StdDraw.setPenColor(0, 0, 170);
        StdDraw.filledRectangle(0.5, 0.6, 0.2, 0.075);
        StdDraw.filledCircle(0.3, 0.6, 0.075);
        StdDraw.filledCircle(0.7, 0.6, 0.075);
        StdDraw.setFont(button);
        StdDraw.setPenColor(255, 255, 255);
        StdDraw.text(0.5, 0.6, "15 × 15");
        //Make subButton2.
        StdDraw.setPenColor(0, 0, 170);
        StdDraw.filledRectangle(0.5, 0.4, 0.2, 0.075);
        StdDraw.filledCircle(0.3, 0.4, 0.075);
        StdDraw.filledCircle(0.7, 0.4, 0.075);
        StdDraw.setFont(button);
        StdDraw.setPenColor(255, 255, 255);
        StdDraw.text(0.5, 0.40, "17 × 17");
        //Make subButton3.
        StdDraw.setPenColor(0, 0, 170);
        StdDraw.filledRectangle(0.5, 0.2, 0.2, 0.075);
        StdDraw.filledCircle(0.3, 0.2, 0.075);
        StdDraw.filledCircle(0.7, 0.2, 0.075);
        StdDraw.setFont(button);
        StdDraw.setPenColor(255, 255, 255);
        StdDraw.text(0.5, 0.2, "19 × 19");

        StdDraw.show();
    }

    public static void chooseColorGUI() {
        StdDraw.clear();
        StdDraw.setPenColor(StdDraw.BLACK);
        final Font title = new Font("SansSerif", Font.BOLD, 30);
        final Font button = new Font("SansSerif", Font.PLAIN, 20);

        StdDraw.setFont( title );
        StdDraw.text( 0.5, 0.8, "You can choose chess color." );
        //Make Button1.
        StdDraw.setPenColor( 0, 0, 170 );
        StdDraw.filledRectangle( 0.5, 0.6, 0.2, 0.075 );
        StdDraw.filledCircle( 0.3, 0.6, 0.075 );
        StdDraw.filledCircle( 0.7, 0.6, 0.075 );
        StdDraw.setFont( button );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.5, 0.6, "I want BLACK." );
        //Make Button2.
        StdDraw.setPenColor( 0, 0, 170 );
        StdDraw.filledRectangle( 0.5, 0.4, 0.2, 0.075 );
        StdDraw.filledCircle( 0.3, 0.4, 0.075 );
        StdDraw.filledCircle( 0.7, 0.4, 0.075 );
        StdDraw.setFont( button );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.5, 0.40, "I want WHITE." );

        StdDraw.show();
    }
    public static void formBoard ( int boardSize ) {
        StdDraw.clear();
        StdDraw.setCanvasSize(640, 640);
        StdDraw.setXscale( 0, (boardSize + 1)*( 1.0 + 1.0/4.0 ) );
        StdDraw.setYscale( 0, (boardSize + 1)*( 1.0 + 1.0/4.0 ) );
        StdDraw.clear();
        StdDraw.setPenColor( 120, 120, 120 );
        StdDraw.filledSquare( (boardSize+1)/2.0, (boardSize+1)/2.0, (boardSize+1)/2.0 );
        StdDraw.setPenColor( StdDraw.BLACK );
        for (int i = 0 ; i < boardSize+1; i++) {
            StdDraw.line(i, boardSize+1, i, 0);
            StdDraw.line(boardSize+1, i, 0, i);
        }

        final Font exit = new Font("SansSerif", Font.PLAIN, 15);
        StdDraw.setPenColor( 204, 34, 0 );
        StdDraw.filledRectangle( 0.9*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1),
                0.05*(boardSize + 1)*( 1.0 + 1.0/4.0 ), 0.03*(boardSize + 1) );
        StdDraw.filledCircle( 0.85*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1), 0.03*(boardSize + 1) );
        StdDraw.filledCircle( 0.95*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1), 0.03*(boardSize + 1) );
        StdDraw.setFont( exit );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.9*(boardSize + 1)*( 1.0 + 1.0/4.0 ), 0.05*(boardSize + 1), "Undo" );

        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );

        StdDraw.show();
    }
    public static void formBoard2 ( int boardSize ) {
        StdDraw.clear();
        StdDraw.setCanvasSize(640, 640);
        StdDraw.setXscale( 0, (boardSize + 1)*( 1.0 + 1.0/4.0 ) );
        StdDraw.setYscale( 0, (boardSize + 1)*( 1.0 + 1.0/4.0 ) );
        StdDraw.clear();
        StdDraw.setPenColor( 120, 120, 120 );
        StdDraw.filledSquare( (boardSize+1)/2.0, (boardSize+1)/2.0, (boardSize+1)/2.0 );
        StdDraw.setPenColor( StdDraw.BLACK );
        for (int i = 0 ; i < boardSize+1; i++) {
            StdDraw.line(i, boardSize+1, i, 0);
            StdDraw.line(boardSize+1, i, 0, i);
        }

        final Font exit = new Font("SansSerif", Font.PLAIN, 15);
        StdDraw.setPenColor( 204, 34, 0 );
        StdDraw.filledRectangle( 0.9*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1),
                0.05*(boardSize + 1)*( 1.0 + 1.0/4.0 ), 0.03*(boardSize + 1) );
        StdDraw.filledCircle( 0.85*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1), 0.03*(boardSize + 1) );
        StdDraw.filledCircle( 0.95*(boardSize + 1)*( 1.0 + 1.0/4.0 ),
                0.05*(boardSize + 1), 0.03*(boardSize + 1) );

        StdDraw.setPenColor(Color.BLACK);
        StdDraw.filledCircle((boardSize+1)/2.0 , (boardSize+1)/2.0 , 0.4);

        StdDraw.setFont( exit );
        StdDraw.setPenColor( 255, 255, 255 );
        StdDraw.text( 0.9*(boardSize + 1)*( 1.0 + 1.0/4.0 ), 0.05*(boardSize + 1), "Undo" );

        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );

        StdDraw.show();
    }
    public static void victoryGUI( int chess ) {
        final Font button = new Font("SansSerif", Font.PLAIN, 20);
        final Font title = new Font("SansSerif", Font.BOLD, 40);
        StdDraw.clear();
        StdDraw.setCanvasSize(512, 512);
        StdDraw.setXscale( 0, 1 );
        StdDraw.setYscale( 0, 1 );
        if ( chess == 1 ) {
            StdDraw.setFont( title );
            StdDraw.setPenColor( 0, 0, 0 );
            StdDraw.text( 0.5, 0.65,
                    "Congratulations!" );
            StdDraw.text( 0.5, 0.55,
                    "WHITE wins!" );
        }
        if ( chess == 2 ) {
            StdDraw.setFont( title );
            StdDraw.setPenColor( 0, 0, 0 );
            StdDraw.text( 0.5, 0.65,
                    "Congratulations!" );
            StdDraw.text( 0.5, 0.55,
                    "BLACK wins!" );
        }
        //Button1.
        StdDraw.setPenColor(0, 0, 170);
        StdDraw.filledRectangle( 0.25, 0.25, 0.1, 0.075);
        StdDraw.filledCircle(0.15, 0.25, 0.075);
        StdDraw.filledCircle(0.35, 0.25, 0.075);
        StdDraw.setFont(button);
        StdDraw.setPenColor(255, 255, 255);
        StdDraw.text(0.25, 0.25, "PLAY AGAIN");
        //Button2.
        StdDraw.setPenColor(204, 34, 0);
        StdDraw.filledRectangle( 0.75, 0.25, 0.1, 0.075);
        StdDraw.filledCircle(0.65, 0.25, 0.075);
        StdDraw.filledCircle(0.85, 0.25, 0.075);
        StdDraw.setFont(button);
        StdDraw.setPenColor(255, 255, 255);
        StdDraw.text(0.75, 0.25, "EXIT");
        StdDraw.show();
    }
    public static void undoTitle( int boardSize, int countUndo, int color, int[][] cross ) {
        final Font tips = new Font("SansSerif", Font.BOLD, 28);
        if ( color == 2 ) {
            StdDraw.setPenColor( Color.white );
            StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                    0.4*( boardSize+1 ),
                    0.05*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
            StdDraw.setPenColor( Color.BLACK );
            StdDraw.setFont(tips);
            StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                    "You undo! BLACK has " + ( 5 - countUndo ) + " time(s) left." );
        }
        else if ( color == 1 ) {
            StdDraw.setPenColor( Color.white );
            StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                    0.4*( boardSize+1 ),
                    0.05*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
            StdDraw.setPenColor( Color.BLACK );
            StdDraw.setFont(tips);
            StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                    "You undo! WHITE has " + ( 5 - countUndo ) + " time(s) left." );
        }
        /*StdDraw.show();
        StdDraw.pause(3000);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        showBoard( boardSize, cross );*/
        StdDraw.show();
    }
    public static void foulTittle( int boardSize, int[][] cross ) {
        final Font tips = new Font("SansSerif", Font.BOLD, 25);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        StdDraw.setPenColor( Color.BLACK );
        StdDraw.setFont(tips);
        StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                "It's a foul! You have no chance to undo!" );
        StdDraw.text( 0.5*( boardSize+1 ), 1.050*( boardSize+1 ),
                "Please make it up." );
        StdDraw.show();
        StdDraw.pause(3000);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        showBoard( boardSize, cross );
    }
    //以上六个为界面构造函数

    public static boolean clickButtonToChooseMode (int buttonOrder) {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if ( 0.225 < x && x < 0.775 && 0.1 * ( (4 - buttonOrder)*2 ) - 0.075 < y && y < 0.1 * ( (4 - buttonOrder)*2 ) + 0.075 )
            return true;
        else return false;
    }
    public static boolean clickButtonToFormSize (int boardSize) {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if ( 0.225 < x && x < 0.775 && 0.1 * ( 21 - boardSize ) - 0.075 < y && y < 0.1 * ( 21 - boardSize ) + 0.075 )
            return true;
        else return false;
    }
    public static boolean clickButtonToExit1() {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if ( 0.82 < x && x < 0.98 && 0.02 < y && y < 0.08 )
            return true;
        else return false;
    }
    public static boolean clickButtonToExit2() {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if ( 0.575 < x && x < 0.925 && 0.175 < y && y < 0.325 )
            return true;
        else return false;
    }
    public static boolean clickButtonToPlayAgain() {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if ( 0.075 < x && x < 0.425 && 0.175 < y && y < 0.325 )
            return true;
        else return false;
    }
    public static boolean clickButtonToUndo( int boardSize ) {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if (
                0.82*(boardSize + 1)*( 1.0 + 1.0/4.0 ) < x && x < 0.98*(boardSize + 1)*( 1.0 + 1.0/4.0 )
                        &&
                        0.02*(boardSize + 1) < y && y < 0.08*(boardSize + 1)
        )
            return true;
        else return false;
    }
    //以上六个为按键判断函数

    public static boolean CanInput( int cross ) {
        double x = StdDraw.mouseX();
        double y = StdDraw.mouseY();
        if( cross == 0 ) return true;
        else return false;
    }
    public static int checkVictory(int x,int y,int chess, int[][] cross, int boardSize ) {
        //横向判断
        int trans = 0;
        for(int i = x-4; i < x+5 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[i][y] == chess) {
                trans++;
            }
            else {
                trans = 0;
            }
            if(trans == 5) return chess;
        }
        //纵向判断
        int longi = 0;
        for(int i = y-4 ; i < y+5 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[x][i] == chess) {
                longi++;
            }
            else {
                longi=0;
            }
            if(longi == 5) return chess;
        }
        //从左上到右下
        int leftUPToDown = 0;
        for(int i = x-4, j = y+4 ; i < x+5 && j > y-5 ; i++, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == chess) {
                leftUPToDown++;
            }else {
                leftUPToDown=0;
            }
            if(leftUPToDown == 5) return chess;
        }
        //从左下到右上
        int leftDownToUP = 0;
        for(int i = x+4, j = y+4; i > x-5 && j > y-5; i--, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == chess) {
                leftDownToUP++;
            }else {
                leftDownToUP=0;
            }
            if(leftDownToUP == 5) return chess;
        }
        return 0;
    }
    public static boolean canUndo( ArrayList<chess> list ) {
        return list.size() > 0;
    }
    public static void showBoard( int boardSize, int[][] cross ) {
        StdDraw.clear();
        formBoard( boardSize );
        for (int i = 1; i < boardSize + 1; i++) {
            for (int j = 1; j < boardSize + 1; j++) {

                if (cross[i][j] == 1) {
                    StdDraw.setPenColor(Color.WHITE);
                    StdDraw.filledCircle(j, i, 0.4);

                }
                if (cross[i][j] == 2) {
                    StdDraw.setPenColor(Color.BLACK);
                    StdDraw.filledCircle(j, i, 0.4);

                }
            }
        }
        StdDraw.show();
    }
    public static boolean hasBlackTriplet( int x, int y, int[][] cross, int boardSize ) {
        //横向判断
        int trans = 0;
        for(int i = x-2; i < x+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[i][y] == 2) {
                if ( cross[i+1][y] == 1 ) return false;
                trans++;
            }
            else if ( cross[i][y] == 1 ) {
                if ( cross[i+1][y] == 2 ) return false;
            }
            else {
                trans = 0;
            }
            if(trans == 3) return true;
        }
        //纵向判断
        int longi = 0;
        for(int i = y-2 ; i < y+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[x][i] == 2) {
                if ( cross[x][i+1] == 1 ) return false;
                longi++;
            }
            else if ( cross[x][i] == 1 ) {
                if ( cross[x][i+1] == 2 ) return false;
            }
            else {
                longi=0;
            }
            if(longi == 3) return true;
        }
        //从左上到右下
        int leftUPToDown = 0;
        for(int i = x-2, j = y+2 ; i < x+3 && j > y-3 ; i++, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i+1][j-1] == 1 ) return false;
                leftUPToDown++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i+1][j-1] == 2 ) return false;
            }
            else {
                leftUPToDown=0;
            }
            if(leftUPToDown == 3) return true;
        }
        //从左下到右上
        int leftDownToUP = 0;
        for(int i = x+2, j = y+2; i > x-3 && j > y-3; i--, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i-1][j-1] == 1 ) return false;
                leftDownToUP++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i-1][j-1] == 2 ) return false;
            }
            else {
                leftDownToUP=0;
            }
            if(leftDownToUP == 3) return true;
        }
        return false;
    }
    public static int findTripletNumber( int x, int y, int[][] cross, int boardSize ) {
        int num = 0;
        //横向判断
        int trans = 0;
        for(int i = x-2; i < x+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[i][y] == 2) {
                if ( cross[i+1][y] == 1 ) return -1;
                trans++;
            }
            else if ( cross[i][y] == 1 ) {
                if ( cross[i+1][y] == 2 ) return -1;
            }
            else {
                trans = 0;
            }
            if(trans == 3) num++;
        }
        //纵向判断
        int longi = 0;
        for(int i = y-2 ; i < y+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[x][i] == 2) {
                if ( cross[x][i+1] == 1 ) return -1;
                longi++;
            }
            else if ( cross[x][i] == 1 ) {
                if ( cross[x][i+1] == 2 ) return -1;
            }
            else {
                longi=0;
            }
            if(longi == 3) num++;
        }
        //从左上到右下
        int leftUPToDown = 0;
        for(int i = x-2, j = y+2 ; i < x+3 && j > y-3 ; i++, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i+1][j-1] == 1 ) return -1;
                leftUPToDown++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i+1][j-1] == 2 ) return -1;
            }
            else {
                leftUPToDown=0;
            }
            if(leftUPToDown == 3) num++;
        }
        //从左下到右上
        int leftDownToUP = 0;
        for(int i = x+2, j = y+2; i > x-3 && j > y-3; i--, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i-1][j-1] == 1 ) return -1;
                leftDownToUP++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i-1][j-1] == 2 ) return -1;
            }
            else {
                leftDownToUP=0;
            }
            if(leftDownToUP == 3) num++;
        }
        return num;
    }
    public static String findOrientation( int x, int y, int[][] cross, int boardSize ) {
        String orientation = "";
        //横向判断
        int trans = 0;
        for(int i = x-2; i < x+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[i][y] == 2) {
                if ( cross[i+1][y] == 1 ) return "null";
                trans++;
            }
            else if ( cross[i][y] == 1 ) {
                if ( cross[i+1][y] == 2 ) return "null";
            }
            else {
                trans = 0;
            }
            if(trans == 3) orientation = "trans";
        }
        //纵向判断
        int longi = 0;
        for(int i = y-2 ; i < y+3 ; i++) {
            if(i < 0 || i >= boardSize+1) continue;
            if(cross[x][i] == 2) {
                if ( cross[x][i+1] == 1 ) return "null";
                longi++;
            }
            else if ( cross[x][i] == 1 ) {
                if ( cross[x][i+1] == 2 ) return "null";
            }
            else {
                longi=0;
            }
            if(longi == 3) orientation = "longi";
        }
        //从左上到右下
        int leftUPToDown = 0;
        for(int i = x-2, j = y+2 ; i < x+3 && j > y-3 ; i++, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i+1][j-1] == 1 ) return "null";
                leftUPToDown++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i+1][j-1] == 2 ) return "null";
            }
            else {
                leftUPToDown=0;
            }
            if(leftUPToDown == 3) orientation = "leftUPToDown";
        }
        //从左下到右上
        int leftDownToUP = 0;
        for(int i = x+2, j = y+2; i > x-3 && j > y-3; i--, j--) {
            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
            if(cross[i][j] == 2) {
                if ( cross[i-1][j-1] == 1 ) return "null";
                leftDownToUP++;
            }
            else if ( cross[i][j] == 1 ) {
                if ( cross[i-1][j-1] == 2 ) return "null";
            }
            else {
                leftDownToUP=0;
            }
            if(leftDownToUP == 3) orientation = "leftDownToUP";
        }
        return orientation;
    }
    public static void forbiddenMove( int[][] cross, ArrayList<chess> list, int boardSize ) {
        chess former = list.get( list.size() - 1 );
        int x = former.getX();
        int y = former.getY();

        list.remove( list.size() - 1 );
        cross[y][x] = 0;

        final Font tips = new Font("SansSerif", Font.BOLD, 25);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        StdDraw.setPenColor( Color.BLACK );
        StdDraw.setFont(tips);
        StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                "This is a forbidden move!" );
        StdDraw.text( 0.5*( boardSize+1 ), 1.050*( boardSize+1 ),
                "Please place it to another place." );

        StdDraw.show();
        StdDraw.pause(3000);

        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        showBoard( boardSize, cross );

    }
    public static boolean isForbiddenMove( int x, int y, int[][] cross, int boardSize ) {
        if ( hasBlackTriplet( x, y, cross, boardSize ) ) {
            if ( findTripletNumber( x, y, cross, boardSize ) >= 2 ) return true;
            else {
                String orientation = findOrientation( x, y, cross, boardSize );
                switch (orientation) {
                    case "trans":
                        for (int i = x - 2; i < x + 3; i++) {
                            if (i < 0 || i >= boardSize + 1) continue;
                            if (findTripletNumber(i, y, cross, boardSize) >= 2) {
                                return true;
                            }
                        }
                        break;
                    case "longi":
                        for (int i = y - 2; i < y + 3; i++) {
                            if (i < 0 || i >= boardSize + 1) continue;
                            if (findTripletNumber(x, i, cross, boardSize) >= 2) {
                                return true;
                            }
                        }
                        break;
                    case "leftUPToDown":
                        for (int i = x - 2, j = y + 2; i < x + 3 && j > y - 3; i++, j--) {
                            if (i < 0 || i >= boardSize + 1 || j < 0 || j >= boardSize + 1) continue;
                            if (findTripletNumber(i, j, cross, boardSize) >= 2) {
                                return true;
                            }
                        }
                        break;
                    case "leftDownToUP":
                        for(int i = x+2, j = y+2; i > x-3 && j > y-3; i--, j--) {
                            if(i < 0 || i >= boardSize+1 || j < 0 || j >= boardSize+1) continue;
                            if(findTripletNumber(i, j, cross, boardSize) >= 2) {
                                return true;
                            }
                        }
                        break;
                }
            }
        }
        return false;
    }

    public static void computerFindBestPlaceAndPutDownAChess( int boardSize, int[][] cross, ArrayList<chess> list, int color ) {
        int[][] score = new int[boardSize+1][boardSize+1];
        for ( int i = 1; i < boardSize+1; i++ ) {
            for ( int j = 1; j < boardSize+1; j++ ) {
                score[i][j] = 0;
            }
        }

        int humanChessNumber = 0;
        int computerChessNumber = 0;
        int quintupletScore = 0;

        int bestX = 0;
        int bestY = 0;
        int maxScore = 0;
//横向
        if ( color == 1 ) {
        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize-3; j++){
                for ( int k = j; k < j+5; k++ ) {
                    if(cross[i][k] == 1) computerChessNumber++;
                    else if(cross[i][k] == 2 ) humanChessNumber++;
                }

                quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                //为该五元组的每个位置添加分数
                for(int k = j; k < j + 5; k++) {
                    score[i][k] += quintupletScore;
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
//纵向
        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize-3; j++){
                for ( int k = j; k < j+5; k++ ) {
                    if(cross[k][i] == 1) computerChessNumber++;
                    else if(cross[k][i] == 2) humanChessNumber++;
                }

                quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                //为该五元组的每个位置添加分数
                for(int k = j; k < j + 5; k++) {
                    score[k][i] += quintupletScore;
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
//右上
        for(int i = boardSize; i >= 5; i--){
            for(int j = 1, k = i; j < boardSize+1 && k >= 1; j++, k--){
                int m = k;
                int n = j;
                while ( m > k-5 && k-5 >= 0 ) {
                    if(cross[m][n] == 1) computerChessNumber++;
                    else if(cross[m][n] == 2) humanChessNumber++;
                    m--;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k-5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                //为该五元组的每个位置添加分数
                    for(m = k, n = j; m > k-5; m--, n++) {
                        score[m][n] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
//左下
        for(int i = 1; i < boardSize+1; i++){
            for(int j = boardSize, k = i; j >= 1 && k < boardSize+1; j--, k++){
                int m = k;
                int n = j;
                while (m < k+5 && k+5 <= boardSize+1) {
                    if(cross[n][m] == 1) computerChessNumber++;
                    else if(cross[n][m] == 2) humanChessNumber++;
                    m++;
                    n--;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                    //为该五元组的每个位置添加分数
                    for(m = k, n = j; m < k+5; m++, n--) {
                        score[n][m] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
//左上
        for(int i = 1; i < boardSize-3; i++){
            for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                int m = k;
                int n = j;
                while ( m < k+5 && k+5 <= boardSize+1 ) {
                    if(cross[m][n] == 1) computerChessNumber++;
                    else if(cross[m][n] == 2) humanChessNumber++;
                    m++;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                    //为该五元组的每个位置添加分数
                    for(m = k, n = j; m < k+5; m++, n++) {
                        score[m][n] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
//右下
        for(int i = 1; i < boardSize-3; i++){
            for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                int m = k;
                int n = j;
                while ( m < k+5 && k+5 <= boardSize+1 ) {
                    if(cross[n][m] == 1) computerChessNumber++;
                    else if(cross[n][m] == 2) humanChessNumber++;
                    m++;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                    //为该五元组的每个位置添加分数
                    for(m = k, n = j; m < k+5; m++, n++) {
                        score[n][m] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;//五元组中的黑棋数量
                computerChessNumber = 0;//五元组中的白棋数量
                quintupletScore = 0;//五元组得分临时变量
            }
        }
        }

        else if ( color == 2 ) {
            for(int i = 1; i < boardSize+1; i++){
                for(int j = 1; j < boardSize-3; j++){
                    for ( int k = j; k < j+5; k++ ) {
                        if(cross[i][k] == 2) computerChessNumber++;
                        else if(cross[i][k] == 1 ) humanChessNumber++;
                    }

                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                    //为该五元组的每个位置添加分数
                    for(int k = j; k < j + 5; k++) {
                        score[i][k] += quintupletScore;
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
//纵向
            for(int i = 1; i < boardSize+1; i++){
                for(int j = 1; j < boardSize-3; j++){
                    for ( int k = j; k < j+5; k++ ) {
                        if(cross[k][i] == 2) computerChessNumber++;
                        else if(cross[k][i] == 1) humanChessNumber++;
                    }

                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                    //为该五元组的每个位置添加分数
                    for(int k = j; k < j + 5; k++) {
                        score[k][i] += quintupletScore;
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
//右上
            for(int i = boardSize; i >= 5; i--){
                for(int j = 1, k = i; j < boardSize+1 && k >= 1; j++, k--){
                    int m = k;
                    int n = j;
                    while ( m > k-5 && k-5 >= 0 ) {
                        if(cross[m][n] == 2) computerChessNumber++;
                        else if(cross[m][n] == 1) humanChessNumber++;
                        m--;
                        n++;
                    }

                    //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                    if(m == k-5){
                        quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                        //为该五元组的每个位置添加分数
                        for(m = k, n = j; m > k-5; m--, n++) {
                            score[m][n] += quintupletScore;
                        }
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
//左下
            for(int i = 1; i < boardSize+1; i++){
                for(int j = boardSize, k = i; j >= 1 && k < boardSize+1; j--, k++){
                    int m = k;
                    int n = j;
                    while (m < k+5 && k+5 <= boardSize+1) {
                        if(cross[n][m] == 2) computerChessNumber++;
                        else if(cross[n][m] == 1) humanChessNumber++;
                        m++;
                        n--;
                    }

                    //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                    if(m == k+5){
                        quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                        //为该五元组的每个位置添加分数
                        for(m = k, n = j; m < k+5; m++, n--) {
                            score[n][m] += quintupletScore;
                        }
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
//左上
            for(int i = 1; i < boardSize-3; i++){
                for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                    int m = k;
                    int n = j;
                    while ( m < k+5 && k+5 <= boardSize+1 ) {
                        if(cross[m][n] == 2) computerChessNumber++;
                        else if(cross[m][n] == 1) humanChessNumber++;
                        m++;
                        n++;
                    }

                    //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                    if(m == k+5){
                        quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                        //为该五元组的每个位置添加分数
                        for(m = k, n = j; m < k+5; m++, n++) {
                            score[m][n] += quintupletScore;
                        }
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
//右下
            for(int i = 1; i < boardSize-3; i++){
                for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                    int m = k;
                    int n = j;
                    while ( m < k+5 && k+5 <= boardSize+1 ) {
                        if(cross[n][m] == 2) computerChessNumber++;
                        else if(cross[n][m] == 1) humanChessNumber++;
                        m++;
                        n++;
                    }

                    //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                    if(m == k+5){
                        quintupletScore = calculateScore( humanChessNumber, computerChessNumber );
                        //为该五元组的每个位置添加分数
                        for(m = k, n = j; m < k+5; m++, n++) {
                            score[n][m] += quintupletScore;
                        }
                    }
                    //置零
                    humanChessNumber = 0;//五元组中的黑棋数量
                    computerChessNumber = 0;//五元组中的白棋数量
                    quintupletScore = 0;//五元组得分临时变量
                }
            }
        }

        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize+1; j++){
                if(cross[i][j] == 0 && score[i][j] > maxScore){
                    bestX = i;
                    bestY = j;
                    maxScore = score[i][j];
                }
            }
        }

        if ( bestX > 0 && bestY > 0 && CanInput( cross[bestX][bestY] ) ) {
            if ( color == 1 ) {
                cross[bestX][bestY] = 1;
                list.add( new chess( bestY, bestX, 1 ) );
            }
            else if ( color == 2 ) {
                cross[bestX][bestY] = 2;
                list.add( new chess( bestY, bestX, 2 ) );
            }
        }
    }
    public static int calculateScore( int humanChessNumber, int computerChessNumber ) {
        //1.既有人类落子，又有机器落子，判分为0
        if(humanChessNumber > 0 && computerChessNumber > 0){
            return 0;
        }
        //2.全部为空，没有落子，判分为7
        if(humanChessNumber == 0 && computerChessNumber == 0){
            return 7;
        }
        //3.机器落1子，判分为35
        if(computerChessNumber == 1){
            return 35;
        }
        //4.机器落2子，判分为800
        if(computerChessNumber == 2){
            return 800;
        }
        //5.机器落3子，判分为15000
        if(computerChessNumber == 3){
            return 15000;
        }
        //6.机器落4子，判分为800000
        if(computerChessNumber == 4){
            return 800000;
        }
        //7.人类落1子，判分为15
        if(humanChessNumber == 1){
            return 15;
        }
        //8.人类落2子，判分为400
        if(humanChessNumber == 2){
            return 400;
        }
        //9.人类落3子，判分为1800
        if(humanChessNumber == 3){
            return 1800;
        }
        //10.人类落4子，判分为100000
        if(humanChessNumber == 4){
            return 100000;
        }
        return -1;//其他结果肯定出错
    }
    //以上八个为棋盘操作函数
}
/*——————致谢：
        人机对战参考资料：人机版五子棋两种算法概述
        原文链接：https://blog.csdn.net/u011587401/article/details/50877828
*/
