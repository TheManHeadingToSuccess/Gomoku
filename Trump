public static void trumpSkill1Tittle( int boardSize ) { //川建国技能1标语
        final Font tips = new Font("SansSerif", Font.BOLD, 23);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        StdDraw.setPenColor( Color.BLACK );
        StdDraw.setFont(tips);
        StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                "TRUMP: Goddamn the two impeachments!" );
        StdDraw.show();

    }
    public static void trumpSkill2Tittle( int boardSize ) { //川建国技能2标语
        final Font tips = new Font("SansSerif", Font.BOLD, 23);
        StdDraw.setPenColor( Color.white );
        StdDraw.filledRectangle( 0.5*( boardSize+1 ), 1.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ),
                0.4*( boardSize+1 ),
                0.125*( boardSize+1 )*( 1.0 + 1.0/4.0 ) );
        StdDraw.setPenColor( Color.BLACK );
        StdDraw.setFont(tips);
        StdDraw.text( 0.5*( boardSize+1 ), 1.125*( boardSize+1 ),
                "TRUMP: Nobody knows China better than me!" );
        StdDraw.show();

    }
    public static void TrumpPutDownAChess                                //趣味人机：川建国
    ( int boardSize, int[][] cross, ArrayList<chess> list, int color )
    {
        double probability = Math.random() * 100;
        ArrayList<chess> findHumanChess = new ArrayList<>();

        if ( 0.0 <= probability && probability <= 10.0 ) {              //技能1：二次弹劾——连下两步
            computerFindBestPlaceAndPutDownAChess( boardSize, cross, list, color );
            computerFindBestPlaceAndPutDownAChess( boardSize, cross, list, color );

            trumpSkill1Tittle( boardSize );
        }
        else if ( 10.0 <= probability && probability <= 20.0 ) {        //技能2：没有人比我更懂爱国——将三个人类下的棋变成自己的棋
            for (int i = 1; i < boardSize + 1; i++) {
                for (int j = 1; j < boardSize + 1; j++) {
                    if ( cross[i][j] == -color ) {
                        chess humanChess = new chess( j, i );
                        findHumanChess.add( humanChess );
                    }
                }
            }

            int position1 = (int)( Math.random() * findHumanChess.size() );
            int position2;
            int position3;
            do {
                position2 = (int)( Math.random() * findHumanChess.size() );
            }while ( position1 == position2 );
            do {
                position3 = (int)( Math.random() * findHumanChess.size() );
            }while ( position1 == position3 || position2 == position3 );

            chess humanChess1 = findHumanChess.get( position1 );
            chess humanChess2 = findHumanChess.get( position2 );
            chess humanChess3 = findHumanChess.get( position3 );

            cross[humanChess1.getX()][humanChess1.getY()] = color;
            cross[humanChess2.getX()][humanChess2.getY()] = color;
            cross[humanChess3.getX()][humanChess3.getY()] = color;

            trumpSkill2Tittle( boardSize );
        }
        else computerFindBestPlaceAndPutDownAChess( boardSize, cross, list, color );
    }

    public static void computerFindBestPlaceAndPutDownAChess( int boardSize, int[][] cross, ArrayList<chess> list, int color )
    {
        int[][] score = new int[boardSize+1][boardSize+1];  //机器核心算法，建议阅读末尾的网址文章后再看
        for ( int i = 1; i < boardSize+1; i++ ) {
            for ( int j = 1; j < boardSize+1; j++ ) {
                score[i][j] = 0;
            }                                                //每个位置权值初始化为0
        }

        int humanChessNumber = 0;  //人下的棋子数
        int computerChessNumber = 0;  //机器下的棋子数
        int quintupletScore;    //五连体分数

        int bestX = 0;    //最优位置x,y
        int bestY = 0;
        int maxScore = 0;  //权值最大值
        //横向
        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize-3; j++){
                for ( int k = j; k < j+5; k++ ) {
                    if(cross[i][k] == color) computerChessNumber++;
                    else if(cross[i][k] == -color ) humanChessNumber++;
                }

                quintupletScore = calculateScore( humanChessNumber, computerChessNumber );   //计算权值
                //为该五连体的每个位置添加分数
                for(int k = j; k < j + 5; k++) {
                    score[i][k] += quintupletScore;
                }
                //置零
                humanChessNumber = 0;//五连体中的人棋数量
                computerChessNumber = 0;//机器棋数量
            }
        }
        //纵向
        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize-3; j++){
                for ( int k = j; k < j+5; k++ ) {
                    if(cross[k][i] == color) computerChessNumber++;
                    else if(cross[k][i] == -color) humanChessNumber++;
                }

                quintupletScore = calculateScore( humanChessNumber, computerChessNumber );

                for(int k = j; k < j + 5; k++) {
                    score[k][i] += quintupletScore;
                }
                //置零
                humanChessNumber = 0;
                computerChessNumber = 0;
            }
        }
        //右上
        for(int i = boardSize; i >= 5; i--){
            for(int j = 1, k = i; j < boardSize+1 && k >= 1; j++, k--){
                int m = k;
                int n = j;
                while ( m > k-5 && k-5 >= 0 ) {
                    if(cross[m][n] == color) computerChessNumber++;
                    else if(cross[m][n] == -color) humanChessNumber++;
                    m--;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五连体（靠近四个角落），遇到这种情况要忽略掉
                if(m == k-5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );

                    for(m = k, n = j; m > k-5; m--, n++) {
                        score[m][n] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;
                computerChessNumber = 0;
            }
        }
        //左下
        for(int i = 1; i < boardSize+1; i++){
            for(int j = boardSize, k = i; j >= 1 && k < boardSize+1; j--, k++){
                int m = k;
                int n = j;
                while (m < k+5 && k+5 <= boardSize+1) {
                    if(cross[n][m] == color) computerChessNumber++;
                    else if(cross[n][m] == -color) humanChessNumber++;
                    m++;
                    n--;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );

                    for(m = k, n = j; m < k+5; m++, n--) {
                        score[n][m] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;
                computerChessNumber = 0;
            }
        }
        //左上
        for(int i = 1; i < boardSize-3; i++){
            for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                int m = k;
                int n = j;
                while ( m < k+5 && k+5 <= boardSize+1 ) {
                    if(cross[m][n] == color) computerChessNumber++;
                    else if(cross[m][n] == -color) humanChessNumber++;
                    m++;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );

                    for(m = k, n = j; m < k+5; m++, n++) {
                        score[m][n] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;
                computerChessNumber = 0;
            }
        }
        //右下
        for(int i = 1; i < boardSize-3; i++){
            for(int j = 1, k = i; j < boardSize+1 && k < boardSize+1; j++, k++){
                int m = k;
                int n = j;
                while ( m < k+5 && k+5 <= boardSize+1 ) {
                    if(cross[n][m] == color) computerChessNumber++;
                    else if(cross[n][m] == -color) humanChessNumber++;
                    m++;
                    n++;
                }

                //注意斜向判断的时候，可能构不成五元组（靠近四个角落），遇到这种情况要忽略掉
                if(m == k+5){
                    quintupletScore = calculateScore( humanChessNumber, computerChessNumber );

                    for(m = k, n = j; m < k+5; m++, n++) {
                        score[n][m] += quintupletScore;
                    }
                }
                //置零
                humanChessNumber = 0;
                computerChessNumber = 0;
            }
        }

        for(int i = 1; i < boardSize+1; i++){
            for(int j = 1; j < boardSize+1; j++){
                if(cross[i][j] == 0 && score[i][j] > maxScore){
                    bestX = i;
                    bestY = j;
                    maxScore = score[i][j];
                }                                                 //找到最高分数所在空位的坐标
            }
        }

        if ( bestX > 0 && bestY > 0 && canInput( cross[bestX][bestY] ) ) {              //填入棋子
            cross[bestX][bestY] = color;
            list.add( new chess( bestY, bestX) );
        }
    }
    public static int calculateScore( int humanChessNumber, int computerChessNumber ) {  //计算权值函数
        //既有人类落子，又有机器落子，判分为0
        if(humanChessNumber > 0 && computerChessNumber > 0){
            return 0;
        }
        //全部为空，没有落子，判分为7
        if(humanChessNumber == 0 && computerChessNumber == 0){
            return 7;
        }
        //机器落1子，判分为35
        if(computerChessNumber == 1){
            return 35;
        }
        //机器落2子，判分为800
        if(computerChessNumber == 2){
            return 800;
        }
        //机器落3子，判分为15000
        if(computerChessNumber == 3){
            return 15000;
        }
        //机器落4子，判分为800000
        if(computerChessNumber == 4){
            return 800000;
        }
        //人类落1子，判分为15
        if(humanChessNumber == 1){
            return 15;
        }
        //人类落2子，判分为400
        if(humanChessNumber == 2){
            return 400;
        }
        //人类落3子，判分为1800
        if(humanChessNumber == 3){
            return 1800;
        }
        //人类落4子，判分为100000
        if(humanChessNumber == 4){
            return 100000;
        }
        return -1;//其他结果肯定出错
    }
